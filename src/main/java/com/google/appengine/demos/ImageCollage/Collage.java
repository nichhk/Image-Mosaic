package com.google.appengine.demos.ImageCollage;

/*
 Update: 12/24
 Added the Image Cache to findImage()
 Added in non-smart sizing to produce evenly sized collages
 Collage: Called by CollageMaster() to generate a collage from a given base image.The collage is generated by recursively
 generating a quad-tree until each block's RGB values are below a given variance threshold. Finally, it generates a List of AttributionCells which
 details the artist and original URL of each color-in image.
*/

import com.google.appengine.api.images.Composite;
import com.google.appengine.api.images.Image;
import com.google.appengine.api.images.ImagesServiceFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ThreadFactory;

public class Collage implements Runnable{

    private  ProcessedImage processedImage; // Base image, which the collage will be built from
    private  Transformer transformer; // Wrapper class for transform
    private  int width, height, maxDepth, varianceThreshhold; // Dimensions of the base image, max recursion depth, and stop condition
    private  Crawler crawler; // Finds images from the database
    private int factor = 1; // Scaling factor of the image, default at 1
    private List<AttributionCell> attributionTable = new ArrayList<AttributionCell>();
    private int initialX,initialY; // Used to define the top left x,y coordinates of the image within the Master-Collage
    private double alpha = .4; // The opacity of the original image in the collage
    private CollageTimer collageTimer; // Used to cut execution of the collage at a given time-limit
    private HashMap<String, ProcessedImage> imageCache;
    private double myTime;
    private ArrayList<Composite> totalImage = new ArrayList<Composite>();
    private ThreadFactory tf;
    private boolean smartSize;
    private int minDepth = 1;


    /*
    Constructs a Collage object, with the default alpha overlay value
    Inputs: inputImg: Image to be turned into a collage
    maxDepth: Maximum recursion depth of the quad-tree
    varianceThreshhold: Stop condition for the quad-tree recursion
    factor: Scaling factor of the image
    crawler: Allows Collage to access the image database
    initialX: The X-coordinate of this base image in the original
    initialY: The Y-coordinate of this base image in the original
    collageTimer: Halts execution at a specified time
    imageCache: Shared cache of the scaled images between all the different Collage threads
     */

    public Collage(Image inputImg, int maxDepth, int varianceThreshhold, Crawler crawler, int initialX, int initialY, CollageTimer collageTimer, HashMap<String, ProcessedImage> imageCache, ThreadFactory tf, boolean smartSize) {
        this.crawler = crawler;
        this.maxDepth = maxDepth;
        this.initialX = initialX;
        this.initialY = initialY;
        this.varianceThreshhold =  varianceThreshhold;
        this.transformer = new Transformer(ImagesServiceFactory.getImagesService());
        this.collageTimer = collageTimer;
        this.imageCache = imageCache;
        this.tf = tf;
        this.smartSize = smartSize;
        height = inputImg.getHeight();
        width = inputImg.getWidth();
        processedImage = new ProcessedImage(inputImg, null, null, null, null, null);
        processedImage.setTransformer(transformer);
        myTime = collageTimer.getRemaining();
    }

    /*
    Returns an Image of the finished, alpha-overlaid collage
     */

    public void createCollage(boolean smartSize, int x1, int x2, int y1, int y2){
        Composite composite;
        if(smartSize){
            composite = ImagesServiceFactory.makeComposite(colorBlock(x1, y1, y2-y1, x2-x1, 0, processedImage,0,myTime,System.nanoTime()),x1, y1, 1f, Composite.Anchor.TOP_LEFT );
        }
        else{
            composite = ImagesServiceFactory.makeComposite(colorBlock(x1, y1, y2-y1, x2-x1, 0, processedImage), x1, y1, 1f, Composite.Anchor.TOP_LEFT);
        }

        totalImage.add(composite);

    }

    /*
    Creates/Returns a collage within a given block of the base-image
    Inputs: firstX: X coordinate of the upper-left corner
    firstY: Y coordinate of the upper-left corner
    partitionHeight: The height of the block
    partitionWidth: The width of the block
    depth: The current recursion depth of the colorBlock() call
    colorMe: Subsection of the base-image to be collaged
     */

    private Image colorBlock(int firstX, int firstY, int partitionHeight, int partitionWidth, int depth, ProcessedImage colorMe, double weight, double thisTime, double startTime){

        if(firstX<width && firstY<height) { // Prevents colorBlock() from creating a collage outside of the given base-image
            if (depth < maxDepth  && System.nanoTime()<(startTime+thisTime)) { // Prevents colorBlock() from recursing past the maxDepth and cuts execution at the set Time
                int halfWidth = partitionWidth / 2; // halfWidth is the width  of the block within the next depth's colorBlock()
                int halfHeight = partitionHeight / 2; // halfHeight is the height of the block within the next depth's colorBlock()
                double variance = colorMe.getVariance();

                // Finds the variance of the RGB values within the block

                if (variance > varianceThreshhold || depth<minDepth ){ // Stops the quad-tree from recursing if the variance is below the threshhold
                    depth++; // Increments the depth for the recursed colorBlock() calls
                    ArrayList<Composite> composites = new ArrayList<Composite>(); // Stores the returned collages from the 4 quadrants of the block
                    Image upperLeft = colorBlock(firstX, firstY, halfHeight, halfWidth, depth, colorMe.getBlock(0, 0, halfHeight, halfWidth),weight+depth*8,(thisTime/4),startTime); // Upper Left, 12, 8
                    Image upperRight = colorBlock(firstX + halfWidth, firstY, halfHeight, partitionWidth - halfWidth, depth, colorMe.getBlock(halfWidth, 0, halfHeight, partitionWidth - halfWidth),weight+depth*4,(thisTime/4),(thisTime/4)+startTime); // Upper Right, 6, 4
                    Image lowerLeft = colorBlock(firstX, firstY + halfHeight, partitionHeight-halfHeight, halfWidth, depth, colorMe.getBlock(0, halfHeight, partitionHeight-halfHeight, halfWidth),weight,(thisTime/4),(thisTime/2)+startTime); // Lower Left, 0
                    Image lowerRight = colorBlock(firstX + halfWidth, firstY + halfHeight, partitionHeight-halfHeight, partitionWidth - halfWidth, depth, colorMe.getBlock(halfWidth, halfHeight, partitionHeight-halfHeight, partitionWidth - halfWidth),weight-depth*1.5,thisTime/4,(thisTime*3/4)+startTime); // Lower Right, -3, -2

                    // Recursively calls colorBlock() on the 4 quadrants of the block


                    composites.add(ImagesServiceFactory.makeComposite(upperLeft,0,0,1f, Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(upperRight, halfWidth*factor, 0, 1f, Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(lowerLeft,0, halfHeight*factor,1f,Composite.Anchor.TOP_LEFT));
                    composites.add(ImagesServiceFactory.makeComposite(lowerRight,(halfWidth)*factor, (halfHeight)*factor,1f,Composite.Anchor.TOP_LEFT));

                    // Transforms all the returned quadrant Images to Composites

                    return transformer.composite(composites, partitionWidth * factor, partitionHeight * factor, 0, 0); // Returns the composited image, scaled by the factor
                }
                else{ // The variance was below the threshold
                    return findImage(colorMe, firstX,firstY, partitionHeight, partitionWidth,depth); // Fills the block with a single image
                }
            }
            else { // This colorBlock() call was already at max depth
                return findImage(colorMe, firstX,firstY,partitionHeight, partitionWidth,depth); // Fills the block with a single image

            }
        }
        return null; // Returns a null image if this colorBlock() modifies pixels outside of the base-image

    }

    /*
    Produces a non-smart sized collage
     */

    private Image colorBlock(int firstX, int firstY, int partitionHeight, int partitionWidth, int depth, ProcessedImage colorMe){

        if (depth < maxDepth) { // Prevents colorBlock() from recursing past the maxDepth and cuts execution at the set Time
            int halfWidth = partitionWidth / 2; // halfWidth is the width  of the block within the next depth's colorBlock()
            int halfHeight = partitionHeight / 2; // halfHeight is the height of the block within the next depth's colorBlock()
            depth++; // Increments the depth for the recursed colorBlock() calls
            ArrayList<Composite> composites = new ArrayList<Composite>(); // Stores the returned collages from the 4 quadrants of the block
            Image upperLeft = colorBlock(firstX, firstY, halfHeight, halfWidth, depth, colorMe.getBlock(0, 0, halfHeight, halfWidth)); // Upper Left, 12, 8
            Image upperRight = colorBlock(firstX + halfWidth, firstY, halfHeight, partitionWidth - halfWidth, depth,
                    colorMe.getBlock(halfWidth, 0, halfHeight, partitionWidth - halfWidth)); // Upper Right, 6, 4
            Image lowerLeft = colorBlock(firstX, firstY + halfHeight, partitionHeight - halfHeight, halfWidth, depth,
                    colorMe.getBlock(0, halfHeight, partitionHeight - halfHeight, halfWidth)); // Lower Left, 0
            Image lowerRight = colorBlock(firstX + halfWidth, firstY + halfHeight, partitionHeight - halfHeight,
                    partitionWidth - halfWidth, depth, colorMe.getBlock(halfWidth, halfHeight, partitionHeight - halfHeight,
                            partitionWidth - halfWidth)); // Lower Right, -3, -2

            // Recursively calls colorBlock() on the 4 quadrants of the block

            composites.add(ImagesServiceFactory.makeComposite(upperLeft, 0, 0, 1f, Composite.Anchor.TOP_LEFT));
            composites.add(ImagesServiceFactory.makeComposite(upperRight, halfWidth, 0, 1f, Composite.Anchor.TOP_LEFT));
            composites.add(ImagesServiceFactory.makeComposite(lowerLeft, 0, halfHeight, 1f, Composite.Anchor.TOP_LEFT));
            composites.add(ImagesServiceFactory.makeComposite(lowerRight, (halfWidth), (halfHeight), 1f, Composite.Anchor.TOP_LEFT));

            // Transforms all the returned quadrant Images to Composites

            return transformer.composite(composites, partitionWidth, partitionHeight, 0,0); // Returns the composited image, scaled by the factor
        }else{
            return findImage(colorMe, firstX,firstY,partitionHeight, partitionWidth,depth); // Fills the block with a single image
        }

    }

    /*
    Returns an image from the database that best matches the RGB histogram of a given block
    Inputs: firstX: X coordinate of the upper-left corner of the block
    firstY: Y coordinate of the upper-left corner of the block
    partitionHeight: height of the block
    partitionWidth: width of the block
    depth: Depth at which findImage() was called
     */

    private Image findImage( ProcessedImage block, int firstX, int firstY, int partitionHeight, int partitionWidth, int depth){

        ProcessedImage processed;
        String key = crawler.ditherQueryKey(block.getRGBHistogram()); // The database key corresponding with the best Flickr image
        if(imageCache.containsKey(key)){ // Checks if the image has already been cached
            processed = imageCache.get(key); // If it has load the corresponding ProcessedImage from the cache
        }
        else{ // Else, load the image from the database
            processed = crawler.loadImage(key);
            processed.setTransformer(transformer);
            imageCache.put(key, processed); // Place the new ProcessedImage in the cache
        }
        attributionTable.add(new AttributionCell(firstX+initialX,firstY+initialY,firstX+initialX+partitionWidth,
                firstY+initialY+partitionHeight,processed.getUsername(),processed.getUrl(),
                processed.getId(), processed.getTitle(), processed.getLicense()));

        // Tracks the location, author, and Url of the Flickr image within the Collage

        return processed.getScaled(partitionWidth,partitionHeight,depth);

        // Returns a scaled version of the selected Flickr image

    }

    /*
    Returns the attributionTable of the Collage
     */


    public List<AttributionCell> getAttributionTable(){

        return attributionTable;

    }

    /*
    Overlays a alpha% opacity copy of the original image on the collage to create a more accurate image
    */

    private Image alphaOverlay(Image collage){

        ArrayList<Composite>composites = new ArrayList<Composite>(); // Stores the composite images
        composites.add(ImagesServiceFactory.makeComposite(processedImage.getImage(),0,0,(float)alpha, Composite.Anchor.TOP_LEFT));

        // Turns the collage into a composite with full opacity

        composites.add(ImagesServiceFactory.makeComposite(collage,0,0,.85f,Composite.Anchor.TOP_LEFT));

        // Turns the original image into a composite with alpha% opacity

        return transformer.composite(composites,width,height,0,0); // Returns the overlaid collage and alpha% opacity base-image

    }
    public Image getCollage(){return alphaOverlay(transformer.composite(totalImage, width, height, 0,0));}


    public int getInitX(){
        return initialX;
    }
    public int getInitY(){
        return initialY;
    }

    /*
    AttributionCell: Stores the author, URL, and position information of the Flickr images within the collage
    */

    public class AttributionCell{

        double x1; // X coordinates of the upper-left corner
        double x2; // X coordinates of the bottom-right corner
        double y1; // Y coordinates of the upper-left corner
        double y2; // Y coordinates of the bottom-right corner
        String author; // Flickr username of the artist
        String trueUrl; // Url of the Flickr image
        String id; // Flickr id of the artist
        String title; //the title of the photo
        String url;
        String license;
        /*
        Constructs an AttributionCell
        Inputs: url: Thumbnail url of the image
        */

        public AttributionCell(double x1, double y1, double x2, double y2, String author, String url, String id, String title, String license){
            this.x1 = x1;
            this.x2 = x2;
            this.y1 = y1;
            this.y2 = y2;
            this.author = author;
            this.id = id;
            if (title == null){
                this.title = "Untitled";
            }
            else{
                this.title = title;
            }
            this.url = url;
            this.license = license;
            findUrl(url); // Constructs the trueUrl from the thumbnail url
        }

        /*
        Constructs the Flickr page url from the thumbnail url and userId
        Inputs: url: thumbnail url
        */

        private void findUrl(String url){

            try {
                String codeNumber = url.split("[^a-zA-Z0-9 ]")[8]; // Splits the thumbnail url to find the image number
                trueUrl = codeNumber.split("_")[0];
                trueUrl = "https://www.flickr.com/photos/" +  id + "/" + trueUrl; // Creates the url of the actual Flickr page
            }catch(Exception e){

                trueUrl = url; // If there was an error, simply return the thumbnail url

            }

        }


    }

    public void run(){

        /*
        ************
        Produces the collage at run()
        ************
        int range = (int)(Math.floor(width)/2);
        Thread t1 = tf.newThread(new biCollage(smartSize, 0, range, 0, height));
        Thread t2 = tf.newThread(new biCollage(smartSize,range, width, 0, height ));
        t1.run();
        t2.run();
        try {
            t1.join();
            t2.join();
        }catch(Exception e){
            System.out.println("Error at Collage run");
        }
        */

        createCollage(smartSize,0,width,0,height);

    }


}
